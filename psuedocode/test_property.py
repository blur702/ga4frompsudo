# 07 - Property Model

This file provides the pseudocode for the `Property` model, which represents a Google Analytics 4 property. It inherits from `BaseModel` and defines its specific attributes and relationships.

**Target Application File:** `app/models/property.py`
**Corresponding Test File (to be generated by LLM):** `tests/unit/models/test_property.py` (The pseudocode for these tests is available in the original `testing-pseudocode.md`)

## Pseudocode (from `models-pseudocode.md` and `testing-pseudocode.md` for tests, refined)

### Application Code (`app/models/property.py`)

```python
"""
GA4 Property Model.
Represents a Google Analytics 4 property, including its attributes and
relationships with other models like Websites and Reports.
"""

import logging
import datetime
from .base_model import BaseModel
# Import other related models if type hinting for relationships is desired,
# e.g., from .website import Website (handle potential circular imports with string hints or careful structuring)

logger = logging.getLogger(__name__)

class Property(BaseModel):
    """
    Represents a Google Analytics 4 (GA4) property.

    This class stores details about a GA4 property, such as its ID, name,
    associated account ID, and timestamps. It inherits common database
    operations from BaseModel.

    Attributes:
        property_id (str): The unique identifier for the GA4 property (e.g., 'properties/123456789').
        property_name (str, optional): The display name of the GA4 property.
        account_id (str, optional): The identifier of the GA4 account this property belongs to.
        create_time (datetime.datetime, optional): The timestamp when the property was created in GA4.
        update_time (datetime.datetime, optional): The timestamp when the property was last updated in GA4.
        # `id` and `database` attributes are inherited from BaseModel.
    """

    @property
    def TABLE_NAME(self) -> str:
        """Returns the database table name for Property records."""
        return 'properties'

    def __init__(self, database,
                 property_id: str,
                 property_name: str = None,
                 account_id: str = None,
                 create_time = None, # Can be str or datetime
                 update_time = None, # Can be str or datetime
                 id_val: int = None):
        """
        Initializes a new instance of the Property model.

        Args:
            database (Database): The database instance for operations.
            property_id (str): The unique GA4 property ID. This is mandatory.
            property_name (str, optional): The display name of the property.
            account_id (str, optional): The GA4 account ID associated with this property.
            create_time (str or datetime.datetime, optional): Property creation timestamp.
                                                               If str, should be ISO 8601 format.
            update_time (str or datetime.datetime, optional): Property last update timestamp.
                                                               If str, should be ISO 8601 format.
            id_val (int, optional): The internal database ID if the record already exists.

        Raises:
            ValueError: If `property_id` is None or empty.
        """
        super().__init__(database, id_val)
        if not property_id:
            raise ValueError("GA4 Property ID (property_id) is mandatory.")

        self.property_id = property_id
        self.property_name = property_name
        self.account_id = account_id

        # Handle datetime conversion if strings are passed
        self.create_time = self._iso_to_datetime(create_time) if isinstance(create_time, str) else create_time
        self.update_time = self._iso_to_datetime(update_time) if isinstance(update_time, str) else update_time


    def _to_dict(self) -> dict:
        """
        Converts the Property model's attributes to a dictionary for database storage.
        Timestamps are converted to ISO 8601 string format.

        Returns:
            dict: A dictionary representation of the Property instance's fields
                  suitable for database insertion or update.
        """
        return {
            'property_id': self.property_id,
            'property_name': self.property_name,
            'account_id': self.account_id,
            'create_time': self._datetime_to_iso(self.create_time),
            'update_time': self._datetime_to_iso(self.update_time)
        }

    @classmethod
    def _from_db_row(cls, row_dict: dict, database_instance):
        """
        Creates a Property instance from a database row (dictionary).
        Timestamps from the database (ISO 8601 strings) are parsed into datetime objects.

        Args:
            row_dict (dict): A dictionary representing a row from the 'properties' table.
            database_instance (Database): The database instance to associate with the new Property instance.

        Returns:
            Property: An instance of the Property model.
        """
        return cls(
            database=database_instance,
            id_val=row_dict.get('id'),
            property_id=row_dict.get('property_id'),
            property_name=row_dict.get('property_name'),
            account_id=row_dict.get('account_id'),
            create_time=row_dict.get('create_time'), # Will be parsed by __init__ if str
            update_time=row_dict.get('update_time')  # Will be parsed by __init__ if str
        )

    def get_websites(self):
        """
        Retrieves all Website instances associated with this Property.

        Returns:
            list: A list of Website model instances linked to this property's internal DB ID.
                  Returns an empty list if no websites are found or an error occurs.
        """
        from .website import Website # Local import to avoid circular dependency issues at module load
        if self.id is None:
            logger.warning(f"Property '{self.property_name}' (GA4 ID: {self.property_id}) has no internal DB ID. Cannot fetch websites.")
            return []
        logger.debug(f"Fetching websites for Property DB ID: {self.id}")
        # Website.find_by_property expects the database ID of the property
        return Website.find_by_property_db_id(self.database, self.id)


    def get_reports(self):
        """
        Retrieves all Report instances associated with this Property.
        Note: This assumes a direct relationship or a way to link reports to properties,
        e.g., if `report_data` links to `property_ga4_id`. A direct link from `reports`
        table to `properties` table might be needed for this to be straightforward.
        For now, this is a placeholder for such functionality.

        Returns:
            list: A list of Report model instances.
        """
        from .report import Report # Local import
        # This requires a way to filter reports by property.
        # If reports store 'property_ga4_id' or a similar link:
        # return Report.find_all(self.database, filters={'property_ga4_id': self.property_id})
        # If ReportData links to report_id and property_ga4_id, it's more complex.
        # For this example, let's assume a direct filter on Report model is possible.
        logger.warning(f"get_reports for Property ID {self.property_id} is a placeholder and needs specific linking logic.")
        # Example if reports had a 'property_db_id' foreign key:
        # if self.id:
        #     return Report.find_all(self.database, filters={'property_db_id': self.id})
        return [] # Placeholder

    @classmethod
    def find_by_account(cls, database_instance, account_id: str):
        """
        Finds all properties associated with a given GA4 account ID.

        Args:
            database_instance (Database): The database instance.
            account_id (str): The GA4 account ID to filter properties by.

        Returns:
            list: A list of Property instances belonging to the specified account.
                  Returns an empty list if no properties are found or an error occurs.
        """
        logger.debug(f"Finding properties by account ID: {account_id}")
        return cls.find_all(database_instance, filters={'account_id': account_id}, order_by="property_name ASC")

    @classmethod
    def find_by_ga4_property_id(cls, database_instance, ga4_property_id: str):
        """
        Finds a property by its unique GA4 Property ID.

        Args:
            database_instance (Database): The database instance.
            ga4_property_id (str): The GA4 Property ID (e.g., 'properties/12345').

        Returns:
            Property or None: The Property instance if found, otherwise None.
        """
        logger.debug(f"Finding property by GA4 Property ID: {ga4_property_id}")
        # Assuming 'property_id' is the column name for GA4 Property ID in the DB
        results = cls.find_all(database_instance, filters={'property_id': ga4_property_id}, limit=1)
        return results[0] if results else None

    def __repr__(self):
        """
        Provides a developer-friendly string representation of the Property instance.
        """
        return (f"<Property(id={self.id}, property_id='{self.property_id}', "
                f"name='{self.property_name}', account_id='{self.account_id}')>")
```
"""
Unit tests for the Property model (app.models.property.Property).
These tests verify the functionality of creating, retrieving, updating,
and deleting Property records, as well as custom finders.
"""

import pytest
import datetime # For checking datetime objects
from app.models.property import Property
from app.models.database import Database # Assuming conftest provides 'db' fixture based on this

# If BaseModel is concrete enough to test its save/delete directly,
# those tests might exist in test_base_model.py. Here we test Property's usage.

def test_property_creation_and_save(db): # 'db' fixture from conftest.py
    """Test creating a new Property instance and saving it to the database."""
    ga4_property_id = "properties/12345"
    property_name = "Test Property Alpha"
    account_id = "accounts/54321"
    create_time_iso = "2023-01-01T10:00:00Z"
    update_time_iso = "2023-01-02T11:00:00Z"

    prop = Property(
        database=db,
        property_id=ga4_property_id,
        property_name=property_name,
        account_id=account_id,
        create_time=create_time_iso,
        update_time=update_time_iso
    )
    
    assert prop.id is None # Should not have an ID before saving
    assert prop.property_id == ga4_property_id
    assert prop.property_name == property_name
    assert isinstance(prop.create_time, datetime.datetime) # __init__ should parse
    
    saved_id = prop.save()
    
    assert saved_id is not None
    assert prop.id == saved_id
    assert prop.id > 0

    # Verify by fetching from DB
    fetched_prop = Property.find_by_id(db, saved_id)
    assert fetched_prop is not None
    assert fetched_prop.id == saved_id
    assert fetched_prop.property_id == ga4_property_id
    assert fetched_prop.property_name == property_name
    assert fetched_prop.account_id == account_id
    assert fetched_prop.create_time.isoformat() + "Z" == create_time_iso.replace("Z","+00:00") # Adjust for timezone if parsed
    assert fetched_prop.update_time.isoformat() + "Z" == update_time_iso.replace("Z","+00:00")


def test_property_find_by_id(db):
    """Test finding an existing Property by its internal database ID."""
    # Setup: Create and save a property first
    prop_initial = Property(db, "properties/99901", "Find Me Property")
    initial_id = prop_initial.save()
    assert initial_id is not None

    # Act: Find the property
    found_prop = Property.find_by_id(db, initial_id)

    # Assert
    assert found_prop is not None
    assert found_prop.id == initial_id
    assert found_prop.property_id == "properties/99901"
    assert found_prop.property_name == "Find Me Property"

def test_property_find_by_id_not_found(db):
    """Test finding a Property by an ID that does not exist."""
    found_prop = Property.find_by_id(db, 99999) # Assuming 99999 does not exist
    assert found_prop is None

def test_property_find_by_ga4_property_id(db):
    """Test finding a property by its unique GA4 Property ID."""
    ga4_id = "properties/uniqueGA4ID789"
    prop_initial = Property(db, ga4_id, "Unique GA4 ID Property")
    prop_initial.save()

    found_prop = Property.find_by_ga4_property_id(db, ga4_id)
    assert found_prop is not None
    assert found_prop.property_id == ga4_id
    assert found_prop.id == prop_initial.id

def test_property_find_by_ga4_property_id_not_found(db):
    """Test finding a property by a GA4 Property ID that doesn't exist."""
    found_prop = Property.find_by_ga4_property_id(db, "properties/nonExistentGA4ID")
    assert found_prop is None


def test_property_find_by_account(db):
    """Test finding all properties associated with a specific account ID."""
    account1_id = "accounts/ACC001"
    account2_id = "accounts/ACC002"

    Property(db, "propA1", "Prop A1", account_id=account1_id).save()
    Property(db, "propA2", "Prop A2", account_id=account1_id).save()
    Property(db, "propB1", "Prop B1", account_id=account2_id).save()

    # Act: Find properties for account1_id
    props_for_acc1 = Property.find_by_account(db, account1_id)

    # Assert
    assert len(props_for_acc1) == 2
    for prop in props_for_acc1:
        assert prop.account_id == account1_id
    
    # Check names if order_by="property_name ASC" is implemented as default in find_by_account
    assert props_for_acc1[0].property_name == "Prop A1" # Assuming sorting
    assert props_for_acc1[1].property_name == "Prop A2"


def test_property_find_all(db):
    """Test finding all properties, possibly with no filters."""
    Property(db, "p1", "P1").save()
    Property(db, "p2", "P2").save()
    
    all_props = Property.find_all(db)
    assert len(all_props) >= 2 # Could be more if other tests left data, ideally tests are isolated

def test_property_update(db):
    """Test updating an existing Property's attributes."""
    prop_to_update = Property(db, "properties/update001", "Original Name", account_id="acc_orig")
    saved_id = prop_to_update.save()
    assert saved_id is not None

    # Act: Modify attributes and save again
    prop_to_update.property_name = "Updated Property Name"
    prop_to_update.account_id = "acc_updated"
    update_result_id = prop_to_update.save()
    assert update_result_id == saved_id # Save on existing object should update

    # Assert: Fetch and verify
    updated_prop_fetched = Property.find_by_id(db, saved_id)
    assert updated_prop_fetched is not None
    assert updated_prop_fetched.property_name == "Updated Property Name"
    assert updated_prop_fetched.account_id == "acc_updated"

def test_property_delete(db):
    """Test deleting a Property from the database."""
    prop_to_delete = Property(db, "properties/delete001", "To Be Deleted")
    saved_id = prop_to_delete.save()
    assert saved_id is not None
    assert prop_to_delete.id == saved_id # ID should be set on instance

    # Act: Delete the property
    delete_result = prop_to_delete.delete()

    # Assert
    assert delete_result is True
    assert prop_to_delete.id is None # ID should be cleared on instance after delete
    
    # Verify it's gone from DB
    deleted_prop_fetched = Property.find_by_id(db, saved_id)
    assert deleted_prop_fetched is None

def test_property_delete_unsaved_instance(db):
    """Test attempting to delete a Property instance that hasn't been saved."""
    unsaved_prop = Property(db, "properties/unsaved001", "Unsaved")
    assert unsaved_prop.id is None
    delete_result = unsaved_prop.delete()
    assert delete_result is False # Should not succeed or error, just return False

def test_property_get_websites_no_id(db):
    """Test get_websites on a Property instance that hasn't been saved (no DB ID)."""
    prop = Property(db, "prop-no-id", "Property Without ID")
    assert prop.id is None
    websites = prop.get_websites()
    assert websites == []

# Add test for get_websites when websites exist (requires Website model and test data)
# Add test for get_reports (requires Report model and linking logic)