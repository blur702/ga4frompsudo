# 06 - Base Model

This file details the pseudocode for the `BaseModel` class. This class will serve as a parent for other model classes, providing common functionalities like saving, deleting, and finding records, thus promoting code reusability.

**Target Application File:** `app/models/base_model.py`
**Corresponding Test File (to be generated by LLM based on `testing-pseudocode.md` principles):** `tests/unit/models/test_base_model.py` (or tests for these functionalities can be part of individual model tests that inherit from `BaseModel`).

## Pseudocode (from `models-pseudocode.md`, refined)

```python
"""
Base model with common database interaction functionalities.
All specific model classes (e.g., Property, Website) in the application
are expected to inherit from this BaseModel to gain common CRUD operations
and other shared database logic.
"""

import logging
from abc import ABC, abstractmethod # For abstract methods if specific implementations are required by subclasses

# Get a logger instance for this module
logger = logging.getLogger(__name__)

class BaseModel(ABC):
    """
    Abstract base class for all database models.

    Provides common methods for database operations such as save, delete,
    and find. Subclasses must implement specific table interactions
    or override these methods if specialized behavior is needed.

    Attributes:
        database (Database): An instance of the Database class for executing queries.
        id (int, optional): The primary key of the model instance in the database.
                            It's typically None for new instances until saved.
    """

    # Subclasses should define their table name.
    # TABLE_NAME = None # Example: 'properties', 'websites', etc.

    def __init__(self, database, id_val=None):
        """
        Initializes the base model with a database instance and an optional ID.

        Args:
            database (Database): An instance of the Database class from `app.models.database`.
            id_val (int, optional): The ID of the model if it's an existing record.
                                   Defaults to None for new records.
        """
        if database is None:
            logger.error("Database instance cannot be None for BaseModel.")
            raise ValueError("Database instance is required for BaseModel.")
        self.database = database
        self.id = id_val # Corresponds to the 'id' INTEGER PRIMARY KEY AUTOINCREMENT column

    @property
    @abstractmethod # Subclasses must define their table name
    def TABLE_NAME(self):
        """The name of the database table for this model."""
        pass

    @abstractmethod # Subclasses must define how to convert their fields to a dict for saving
    def _to_dict(self):
        """
        Converts the model's attributes to a dictionary suitable for database insertion or update.
        Excludes 'id' if it's None (for inserts) and internal attributes like 'database'.
        This method MUST be implemented by subclasses.

        Returns:
            dict: A dictionary representation of the model's savable fields.
        """
        pass

    @classmethod
    @abstractmethod # Subclasses must define how to create an instance from a db row
    def _from_db_row(cls, row_dict, database_instance):
        """
        Creates an instance of the model from a database row (dictionary).
        This method MUST be implemented by subclasses.

        Args:
            row_dict (dict): A dictionary representing a row from the database.
            database_instance (Database): The database instance to associate with the new model instance.

        Returns:
            An instance of the subclass model.
        """
        pass

    def save(self):
        """
        Saves the current model instance to the database.
        If the instance has an ID, it attempts an UPDATE.
        Otherwise, it performs an INSERT.

        The specific fields to save are determined by the `_to_dict()` method
        implemented in the subclass. The `id` is automatically handled.

        Returns:
            int or None: The ID of the saved record (newly inserted or existing).
                         Returns None if the save operation failed.
        """
        data_to_save = self._to_dict() # Get fields from subclass
        if not data_to_save:
            logger.warning(f"No data to save for model {self.__class__.__name__}. _to_dict() returned empty.")
            return None

        try:
            if self.id is not None: # Existing record, perform UPDATE
                logger.debug(f"Updating record ID {self.id} in table {self.TABLE_NAME} with data: {data_to_save}")
                # Construct SET clause: "field1 = ?, field2 = ?"
                set_clause = ", ".join([f"{key} = ?" for key in data_to_save.keys()])
                values = list(data_to_save.values()) + [self.id]
                query = f"UPDATE {self.TABLE_NAME} SET {set_clause} WHERE id = ?"
                self.database.execute_query(query, tuple(values), commit=True)
                logger.info(f"Record ID {self.id} updated successfully in {self.TABLE_NAME}.")
                return self.id
            else: # New record, perform INSERT
                logger.debug(f"Inserting new record into table {self.TABLE_NAME} with data: {data_to_save}")
                columns = ", ".join(data_to_save.keys())
                placeholders = ", ".join(["?"] * len(data_to_save))
                values = tuple(data_to_save.values())
                query = f"INSERT INTO {self.TABLE_NAME} ({columns}) VALUES ({placeholders})"

                last_row_id = self.database.execute_query(query, values, commit=True)
                if last_row_id is not None:
                    self.id = last_row_id # Update the instance with the new ID
                    logger.info(f"New record inserted into {self.TABLE_NAME} with ID: {self.id}.")
                    return self.id
                else:
                    logger.error(f"Failed to retrieve last_row_id after insert into {self.TABLE_NAME}.")
                    return None
        except Exception as e: # Catch more specific sqlite3.Error if possible
            logger.error(f"Error saving record to table {self.TABLE_NAME}: {e}", exc_info=True)
            return None


    def delete(self):
        """
        Deletes the current model instance from the database based on its ID.
        If the instance does not have an ID (i.e., it hasn't been saved yet),
        this method does nothing.

        Returns:
            bool: True if the deletion was successful, False otherwise.
        """
        if self.id is None:
            logger.warning(f"Attempted to delete a record from {self.TABLE_NAME} without an ID. Operation aborted.")
            return False
        try:
            logger.debug(f"Deleting record ID {self.id} from table {self.TABLE_NAME}.")
            query = f"DELETE FROM {self.TABLE_NAME} WHERE id = ?"
            cursor = self.database.execute_query(query, (self.id,), commit=True)
            if cursor.rowcount > 0:
                logger.info(f"Record ID {self.id} deleted successfully from {self.TABLE_NAME}.")
                self.id = None # Clear ID after deletion
                return True
            else:
                logger.warning(f"No record found with ID {self.id} in {self.TABLE_NAME} to delete.")
                return False # No rows affected, likely means record didn't exist
        except Exception as e: # Catch more specific sqlite3.Error if possible
            logger.error(f"Error deleting record ID {self.id} from table {self.TABLE_NAME}: {e}", exc_info=True)
            return False

    @classmethod
    def find_by_id(cls, database_instance, record_id):
        """
        Finds a record by its primary key (ID) in the model's table.

        Args:
            database_instance (Database): An instance of the Database class.
            record_id (int): The ID of the record to find.

        Returns:
            An instance of the model subclass if found, otherwise None.
        """
        if not hasattr(cls, 'TABLE_NAME') or not cls.TABLE_NAME:
            logger.error(f"Model class {cls.__name__} does not have TABLE_NAME defined.")
            return None
        try:
            logger.debug(f"Finding record by ID {record_id} in table {cls.TABLE_NAME}.")
            query = f"SELECT * FROM {cls.TABLE_NAME} WHERE id = ?"
            row_dict = database_instance.execute_query(query, (record_id,), fetch_one=True)
            if row_dict:
                return cls._from_db_row(row_dict, database_instance) # Use subclass's factory method
            return None
        except Exception as e: # Catch more specific sqlite3.Error if possible
            logger.error(f"Error finding record by ID {record_id} in table {cls.TABLE_NAME}: {e}", exc_info=True)
            return None

    @classmethod
    def find_all(cls, database_instance, filters=None, order_by=None, limit=None, offset=None):
        """
        Finds all records in the model's table, with optional filters, ordering, and pagination.

        Args:
            database_instance (Database): An instance of the Database class.
            filters (dict, optional): A dictionary of field-value pairs to filter by (e.g., {'name': 'Test'}).
                                      Currently supports exact matches with AND conditions.
            order_by (str, optional): A string specifying the ordering (e.g., "name ASC", "create_time DESC").
            limit (int, optional): The maximum number of records to return.
            offset (int, optional): The number of records to skip (for pagination).

        Returns:
            list: A list of model subclass instances, or an empty list if no records match or an error occurs.
        """
        if not hasattr(cls, 'TABLE_NAME') or not cls.TABLE_NAME:
            logger.error(f"Model class {cls.__name__} does not have TABLE_NAME defined.")
            return []

        query = f"SELECT * FROM {cls.TABLE_NAME}"
        params = []

        if filters:
            # Simple AND filter for now. For complex queries, consider a query builder.
            # WARNING: Ensure filter keys are actual column names to prevent SQL injection if not careful,
            # though parameterization helps. Best to validate keys against known columns.
            # For this example, assuming keys are safe.
            conditions = []
            for key, value in filters.items():
                conditions.append(f"{key} = ?") # Basic equality
                params.append(value)
            if conditions:
                query += " WHERE " + " AND ".join(conditions)

        if order_by:
            # Basic ORDER BY. Be cautious with user-supplied `order_by` strings to prevent SQL injection.
            # It's safer to validate `order_by` against a list of allowed columns and directions.
            # For this example, assuming it's safe or internally generated.
            query += f" ORDER BY {order_by}" # This part is not parameterized, be careful

        if limit is not None:
            query += " LIMIT ?"
            params.append(limit)

        if offset is not None:
            if limit is None: # SQLite requires LIMIT with OFFSET
                query += " LIMIT -1" # Effectively no limit, but required by SQLite for OFFSET
            query += " OFFSET ?"
            params.append(offset)

        try:
            logger.debug(f"Finding all records in table {cls.TABLE_NAME} with query: {query}, params: {params}")
            rows = database_instance.execute_query(query, tuple(params), fetch_all=True)
            if rows:
                return [cls._from_db_row(row_dict, database_instance) for row_dict in rows]
            return []
        except Exception as e: # Catch more specific sqlite3.Error if possible
            logger.error(f"Error finding all records in table {cls.TABLE_NAME}: {e}", exc_info=True)
            return []

    # Helper for subclasses to manage datetime fields consistently
    def _format_datetime_for_db(self, dt_obj):
        """Formats a datetime object to an ISO 8601 string for database storage."""
        if dt_obj:
            return dt_obj.isoformat()
        return None

    def _parse_datetime_from_db(self, dt_str):
        """Parses an ISO 8601 string from the database into a datetime object."""
        if dt_str:
            from datetime import datetime # Local import
            try:
                return datetime.fromisoformat(dt_str)
            except ValueError:
                logger.warning(f"Could not parse datetime string '{dt_str}' from DB for {self.__class__.__name__} ID {self.id}")
                return None # Or handle error as appropriate
        return None
```
