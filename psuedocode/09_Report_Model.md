# 09 - Report Model

This file provides the pseudocode for the `Report` model. This model will store metadata about generated reports, such as their name, type, the parameters used for generation, creation time, status, and a path to the report file if applicable. It inherits from `BaseModel`.

**Target Application File:** `app/models/report.py`
**Corresponding Test File (to be generated by LLM):** `tests/unit/models/test_report.py`. The LLM should adapt tests from the original `testing-pseudocode.md` to align with the refined `Report` model specified here.

## Pseudocode for Application Code (`app/models/report.py`)

```python
"""
Report Model.
Represents metadata for generated analytics reports.
"""

import logging
import datetime
import json # For serializing/deserializing parameters
from typing import Optional, List, Dict, Any, TYPE_CHECKING
from .base_model import BaseModel

if TYPE_CHECKING:
    from .report_data import ReportData # pylint: disable=cyclic-import
    from .database import Database

logger = logging.getLogger(__name__)

class Report(BaseModel):
    """
    Represents metadata for a generated or to-be-generated analytics report.

    This class stores information about a report, such as its name, type
    (which might determine the generation logic or plugin used), the parameters
    it was generated with, its creation timestamp, current status (e.g., pending,
    completed, failed), and a path to the actual report file if one is produced.
    It inherits from `BaseModel` for common database operations.

    Attributes:
        report_name (str): The user-defined or system-generated name for the report.
        report_type (str): A string identifying the type of report (e.g., 'traffic_overview',
                           'engagement_summary', 'custom_plugin_report').
        parameters (Optional[Dict[str, Any]]): A dictionary of parameters used to generate
                                                the report. Stored as a JSON string in the database.
        create_time (datetime.datetime): Timestamp when this report record was created.
        status (Optional[str]): The current status of the report generation process
                                (e.g., 'pending', 'generating', 'completed', 'failed').
        file_path (Optional[str]): The filesystem path to the generated report file (e.g., a PDF).
        # `id` (internal DB primary key) and `database` attributes are inherited from BaseModel.
    """

    @property
    def TABLE_NAME(self) -> str:
        """Returns the database table name used for storing Report records."""
        return 'reports' # As defined in Database.initialize_schema()

    def __init__(self, database: 'Database',
                 report_name: str,
                 report_type: str,
                 parameters: Optional[Dict[str, Any]] = None,
                 create_time: Optional[str | datetime.datetime] = None, # Will default to now if None
                 status: Optional[str] = 'pending',
                 file_path: Optional[str] = None,
                 id_val: Optional[int] = None):
        """
        Initializes a new instance of the Report model.

        Args:
            database (Database): The database instance for data operations.
            report_name (str): The name of the report. Mandatory.
            report_type (str): The type of the report. Mandatory.
            parameters (Optional[Dict[str, Any]]): Parameters used for report generation.
            create_time (Optional[str | datetime.datetime]): Report record creation timestamp.
                Defaults to the current time if None. If str, should be ISO 8601.
            status (Optional[str]): Current status of the report. Defaults to 'pending'.
            file_path (Optional[str]): Path to the generated report file.
            id_val (Optional[int]): The internal database ID if the record already exists.

        Raises:
            ValueError: If `report_name` or `report_type` is None or empty.
        """
        super().__init__(database, id_val)
        if not report_name:
            logger.error("Attempted to initialize Report model without a 'report_name'.")
            raise ValueError("Report name (report_name) is mandatory and cannot be empty.")
        if not report_type:
            logger.error("Attempted to initialize Report model without a 'report_type'.")
            raise ValueError("Report type (report_type) is mandatory and cannot be empty.")

        self.report_name: str = report_name
        self.report_type: str = report_type
        self.parameters: Optional[Dict[str, Any]] = parameters if parameters is not None else {}

        if create_time is None:
            self.create_time: datetime.datetime = datetime.datetime.now(datetime.timezone.utc)
        elif isinstance(create_time, str):
            self.create_time: Optional[datetime.datetime] = self._iso_to_datetime(create_time)
            if self.create_time is None: # Parsing failed, default or raise
                 logger.warning(f"Failed to parse create_time string '{create_time}', defaulting to now.")
                 self.create_time = datetime.datetime.now(datetime.timezone.utc)
        else: # Assumed datetime object
            self.create_time: datetime.datetime = create_time

        self.status: Optional[str] = status
        self.file_path: Optional[str] = file_path

    def _to_dict(self) -> dict:
        """
        Serializes the Report model's attributes to a dictionary for database storage.
        The `parameters` dictionary is converted to a JSON string.
        The `create_time` datetime object is converted to an ISO 8601 string.

        Returns:
            dict: A dictionary representation of the Report instance's fields.
        """
        return {
            'report_name': self.report_name,
            'report_type': self.report_type,
            'parameters': json.dumps(self.parameters) if self.parameters is not None else None,
            'create_time': self._datetime_to_iso(self.create_time), # Should always have a value
            'status': self.status,
            'file_path': self.file_path
        }

    @classmethod
    def _from_db_row(cls, row_dict: dict, database_instance: 'Database') -> 'Report':
        """
        Factory class method to create a Report instance from a database row (dictionary).
        Parses the JSON string for `parameters` back into a dictionary and the
        ISO 8601 string for `create_time` into a datetime object.

        Args:
            row_dict (dict): A dictionary representing a single row from the 'reports' table.
            database_instance (Database): The database instance to associate with the new Report.

        Returns:
            Report: An instance of the Report model.
        """
        parameters_json = row_dict.get('parameters')
        parameters_dict = None
        if parameters_json:
            try:
                parameters_dict = json.loads(parameters_json)
            except json.JSONDecodeError:
                logger.error(f"Failed to decode JSON parameters for report ID {row_dict.get('id')}: {parameters_json}")
                parameters_dict = {} # Default to empty dict or handle error as appropriate

        return cls(
            database=database_instance,
            id_val=row_dict.get('id'),
            report_name=row_dict.get('report_name'),
            report_type=row_dict.get('report_type'),
            parameters=parameters_dict,
            create_time=row_dict.get('create_time'), # __init__ handles parsing if str
            status=row_dict.get('status'),
            file_path=row_dict.get('file_path')
        )

    def get_data(self) -> List['ReportData']:
        """
        Retrieves all ReportData instances associated with this Report's database ID.

        Returns:
            List[ReportData]: A list of ReportData model instances linked to this report.
                              Returns an empty list if this Report has no ID (not saved),
                              no data is found, or an error occurs.
        """
        from .report_data import ReportData # Local import
        if self.id is None:
            logger.warning(
                f"Report '{self.report_name}' has no internal DB ID. Cannot fetch report data. Save the report first."
            )
            return []
        logger.debug(f"Fetching data for Report (DB ID: {self.id}, Name: '{self.report_name}')")
        # Assumes ReportData model has a class method `find_by_report_db_id`
        return ReportData.find_by_report_db_id(self.database, self.id)

    def update_status(self, new_status: str, file_path: Optional[str] = None) -> bool:
        """
        Updates the status of the report and optionally its file path, then saves the changes.

        Args:
            new_status (str): The new status for the report (e.g., 'generating', 'completed', 'failed').
            file_path (Optional[str]): The new file path if the report generation is completed
                                       or if the path needs updating. If None, file_path is not changed unless
                                       new_status implies completion and file_path was previously None.

        Returns:
            bool: True if the status (and optionally file_path) was successfully updated and saved,
                  False otherwise.
        """
        if not self.id:
            logger.error(f"Cannot update status for report '{self.report_name}' as it has no ID (not saved).")
            return False

        logger.info(f"Updating status for report ID {self.id} ('{self.report_name}') to '{new_status}'.")
        self.status = new_status
        if file_path is not None: # Explicitly update file_path if provided
            self.file_path = file_path
        elif new_status == 'completed' and self.file_path is None:
             logger.warning(f"Report ID {self.id} status updated to 'completed' but no file_path provided and current is None.")


        return self.save() is not None # save() returns the ID or None

    @classmethod
    def find_by_type(cls, database_instance: 'Database', report_type: str) -> List['Report']:
        """
        Finds all Report instances of a specific type, ordered by creation time (most recent first).

        Args:
            database_instance (Database): The database instance.
            report_type (str): The type of reports to find.

        Returns:
            List[Report]: A list of Report instances of the specified type.
        """
        logger.debug(f"Finding reports by type: '{report_type}'")
        return cls.find_all(database_instance, filters={'report_type': report_type}, order_by="create_time DESC")

    @classmethod
    def find_by_status(cls, database_instance: 'Database', status: str) -> List['Report']:
        """
        Finds all Report instances with a specific status, ordered by creation time (most recent first).

        Args:
            database_instance (Database): The database instance.
            status (str): The status to filter reports by (e.g., 'pending', 'completed').

        Returns:
            List[Report]: A list of Report instances with the specified status.
        """
        logger.debug(f"Finding reports by status: '{status}'")
        return cls.find_all(database_instance, filters={'status': status}, order_by="create_time DESC")

    def __repr__(self) -> str:
        """
        Provides a developer-friendly string representation of the Report instance.
        """
        return (
            f"<Report(id={self.id}, name='{self.report_name}', type='{self.report_type}', "
            f"status='{self.status}', created='{self.create_time.strftime('%Y-%m-%d %H:%M') if self.create_time else 'N/A'}')>"
        )
```
