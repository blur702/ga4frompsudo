# 10 - Report Data Model

This file provides the pseudocode for the `ReportData` model. This model is designed to store individual data points or aggregated metrics that constitute a generated report, linking back to a specific `Report` instance and potentially a GA4 Property. It inherits from `BaseModel`.

**Target Application File:** `app/models/report_data.py`
**Corresponding Test File (to be generated by LLM):** `tests/unit/models/test_report_data.py`. The LLM should adapt tests from the original `testing-pseudocode.md` to align with the refined `ReportData` model specified here.

## Pseudocode for Application Code (`app/models/report_data.py`)

```python
"""
Report Data Model.
Stores individual data points or metrics associated with a generated Report.
"""

import logging
import datetime
from typing import Optional, List, Any, TYPE_CHECKING
from .base_model import BaseModel

if TYPE_CHECKING:
    from .report import Report       # pylint: disable=cyclic-import
    from .property import Property   # pylint: disable=cyclic-import
    from .database import Database

logger = logging.getLogger(__name__)

class ReportData(BaseModel):
    """
    Represents an individual piece of data or a metric belonging to a generated Report.

    This model is designed to be flexible, storing various types of data points that
    might make up a report, such as specific metrics, their values, associated dimensions,
    the relevant date, and a link back to the parent Report.

    Attributes:
        report_db_id (int): The internal database ID of the `Report` this data point belongs to. (FK)
        property_ga4_id (Optional[str]): The GA4 Property ID this data point specifically relates to,
                                          if applicable (e.g., if a report covers multiple properties).
        metric_name (str): The name of the metric (e.g., 'totalUsers', 'sessions', 'conversionRate').
        metric_value (Optional[str]): The value of the metric. Stored as a string for flexibility
                                      and should be cast to the appropriate type (int, float) on retrieval.
        dimension_name (Optional[str]): The name of the primary dimension associated with this metric
                                        (e.g., 'date', 'country', 'sourceMedium').
        dimension_value (Optional[str]): The value of the primary dimension.
        data_date (Optional[datetime.date]): The specific date this data point or metric refers to.
                                             Stored as a 'YYYY-MM-DD' string in the database.
        data_timestamp (datetime.datetime): Timestamp when this specific data record was created/saved.
        # `id` (internal DB primary key for this data record) and `database` attributes are inherited.
    """

    @property
    def TABLE_NAME(self) -> str:
        """Returns the database table name used for storing ReportData records."""
        return 'report_data' # As defined in Database.initialize_schema()

    def __init__(self, database: 'Database',
                 report_db_id: int,
                 metric_name: str,
                 metric_value: Optional[Any] = None, # Will be cast to str for DB
                 property_ga4_id: Optional[str] = None,
                 dimension_name: Optional[str] = None,
                 dimension_value: Optional[str] = None,
                 data_date: Optional[str | datetime.date] = None, # Date for the data point
                 data_timestamp: Optional[str | datetime.datetime] = None, # When this record was saved
                 id_val: Optional[int] = None):
        """
        Initializes a new instance of the ReportData model.

        Args:
            database (Database): The database instance for data operations.
            report_db_id (int): The ID of the parent Report. Mandatory.
            metric_name (str): The name of the metric. Mandatory.
            metric_value (Optional[Any]): The value of the metric. Will be stored as string.
            property_ga4_id (Optional[str]): GA4 Property ID this data relates to.
            dimension_name (Optional[str]): Name of the primary dimension.
            dimension_value (Optional[str]): Value of the primary dimension.
            data_date (Optional[str | datetime.date]): The specific date for this data point.
                                                       If str, should be 'YYYY-MM-DD'.
            data_timestamp (Optional[str | datetime.datetime]): Timestamp of record creation.
                Defaults to now if None. If str, should be ISO 8601.
            id_val (Optional[int]): The internal database ID if the record already exists.

        Raises:
            ValueError: If `report_db_id` or `metric_name` is None or invalid.
        """
        super().__init__(database, id_val)
        if report_db_id is None: # report_db_id can be 0 if valid, check for None
            logger.error("Attempted to initialize ReportData model without a 'report_db_id'.")
            raise ValueError("Parent Report database ID (report_db_id) is mandatory.")
        if not metric_name:
            logger.error("Attempted to initialize ReportData model without a 'metric_name'.")
            raise ValueError("Metric name (metric_name) is mandatory and cannot be empty.")

        self.report_db_id: int = report_db_id
        self.property_ga4_id: Optional[str] = property_ga4_id
        self.metric_name: str = metric_name
        # Store metric_value as string for DB flexibility, cast on application use
        self.metric_value: Optional[str] = str(metric_value) if metric_value is not None else None
        self.dimension_name: Optional[str] = dimension_name
        self.dimension_value: Optional[str] = dimension_value

        if isinstance(data_date, datetime.datetime): # If datetime, convert to date
            self.data_date: Optional[datetime.date] = data_date.date()
        elif isinstance(data_date, datetime.date):
            self.data_date: Optional[datetime.date] = data_date
        elif isinstance(data_date, str):
            parsed_date = self._iso_to_date(data_date) # Use a new helper for date-only strings
            if parsed_date is None and data_date: # Parsing failed but string was not empty
                logger.warning(f"Failed to parse data_date string '{data_date}', setting to None.")
            self.data_date: Optional[datetime.date] = parsed_date
        else:
            self.data_date: Optional[datetime.date] = None

        if data_timestamp is None:
            self.data_timestamp: datetime.datetime = datetime.datetime.now(datetime.timezone.utc)
        elif isinstance(data_timestamp, str):
            parsed_dt = self._iso_to_datetime(data_timestamp)
            if parsed_dt is None: # Parsing failed
                 logger.warning(f"Failed to parse data_timestamp string '{data_timestamp}', defaulting to now.")
                 self.data_timestamp = datetime.datetime.now(datetime.timezone.utc)
            else:
                self.data_timestamp: datetime.datetime = parsed_dt
        else: # Assumed datetime object
            self.data_timestamp: datetime.datetime = data_timestamp


    def _to_dict(self) -> dict:
        """
        Serializes the ReportData model's attributes to a dictionary for database storage.
        `data_date` (date object) and `data_timestamp` (datetime object) are converted to ISO 8601 strings.
        `metric_value` is already a string.

        Returns:
            dict: A dictionary representation of the ReportData instance's fields.
        """
        return {
            'report_db_id': self.report_db_id,
            'property_ga4_id': self.property_ga4_id,
            'metric_name': self.metric_name,
            'metric_value': self.metric_value, # Already string or None
            'dimension_name': self.dimension_name,
            'dimension_value': self.dimension_value,
            'data_date': self._date_to_iso(self.data_date), # Use new helper for date
            'data_timestamp': self._datetime_to_iso(self.data_timestamp) # Should always have value
        }

    @classmethod
    def _from_db_row(cls, row_dict: dict, database_instance: 'Database') -> 'ReportData':
        """
        Factory class method to create a ReportData instance from a database row (dictionary).
        Parses ISO 8601 string for `data_date` into a date object and for `data_timestamp`
        into a datetime object via `__init__`.

        Args:
            row_dict (dict): A dictionary representing a single row from the 'report_data' table.
            database_instance (Database): The database instance to associate with the new instance.

        Returns:
            ReportData: An instance of the ReportData model.
        """
        return cls(
            database=database_instance,
            id_val=row_dict.get('id'),
            report_db_id=row_dict.get('report_db_id'),
            property_ga4_id=row_dict.get('property_ga4_id'),
            metric_name=row_dict.get('metric_name'),
            metric_value=row_dict.get('metric_value'), # Stored as string
            dimension_name=row_dict.get('dimension_name'),
            dimension_value=row_dict.get('dimension_value'),
            data_date=row_dict.get('data_date'),       # __init__ will parse if str
            data_timestamp=row_dict.get('data_timestamp') # __init__ will parse if str
        )

    def get_report(self) -> Optional['Report']:
        """
        Retrieves the parent Report instance to which this ReportData record belongs.

        Returns:
            Optional[Report]: The parent Report instance, or None if not found.
        """
        from .report import Report # Local import
        if self.report_db_id is None:
            logger.warning("ReportData instance has no parent 'report_db_id'. Cannot fetch report.")
            return None
        logger.debug(f"Fetching parent Report for ReportData ID {self.id} using report_db_id: {self.report_db_id}")
        return Report.find_by_id(self.database, self.report_db_id)

    def get_property(self) -> Optional['Property']:
        """
        Retrieves the GA4 Property instance this ReportData record is associated with,
        if `property_ga4_id` is set.

        Returns:
            Optional[Property]: The associated Property instance, or None if `property_ga4_id`
                                is not set or the property is not found.
        """
        from .property import Property # Local import
        if not self.property_ga4_id:
            logger.debug(f"ReportData ID {self.id} has no 'property_ga4_id'. Cannot fetch property.")
            return None
        logger.debug(f"Fetching associated Property for ReportData ID {self.id} using property_ga4_id: {self.property_ga4_id}")
        return Property.find_by_ga4_id(self.database, self.property_ga4_id)


    @classmethod
    def find_by_report_db_id(cls, database_instance: 'Database', report_db_id: int) -> List['ReportData']:
        """
        Finds all ReportData instances associated with a given internal Report database ID.
        Results are ordered by the data timestamp.

        Args:
            database_instance (Database): The database instance for the query.
            report_db_id (int): The internal database ID of the parent Report.

        Returns:
            List[ReportData]: A list of ReportData instances linked to the specified report DB ID.
        """
        if report_db_id is None:
            logger.warning("Attempted to find report data by report_db_id with a None ID.")
            return []
        logger.debug(f"Finding all report data for parent report_db_id: {report_db_id}")
        return cls.find_all(database_instance, filters={'report_db_id': report_db_id}, order_by="data_timestamp ASC, id ASC")

    @classmethod
    def find_by_property_and_date(cls, database_instance: 'Database', property_ga4_id: str, data_date: str | datetime.date) -> List['ReportData']:
        """
        Finds all ReportData instances for a specific GA4 property ID and a specific date.

        Args:
            database_instance (Database): The database instance.
            property_ga4_id (str): The GA4 Property ID to filter by.
            data_date (str | datetime.date): The specific date (YYYY-MM-DD string or date object) to filter by.

        Returns:
            List[ReportData]: A list of ReportData instances.
        """
        if not property_ga4_id:
            logger.warning("Attempted to find report data by property and date with an empty or None property_ga4_id.")
            return []
        if data_date is None:
            logger.warning("Attempted to find report data by property and date with a None data_date.")
            return []

        date_str = data_date.isoformat() if isinstance(data_date, datetime.date) else data_date
        # Ensure date_str is in 'YYYY-MM-DD' format if it's a string coming in
        try:
            datetime.datetime.strptime(date_str, '%Y-%m-%d') # Validate format
        except ValueError:
            logger.error(f"Invalid date format '{date_str}' for find_by_property_and_date. Expected YYYY-MM-DD.")
            return []

        logger.debug(f"Finding report data for property_ga4_id: '{property_ga4_id}' and data_date: '{date_str}'")
        return cls.find_all(database_instance, filters={'property_ga4_id': property_ga4_id, 'data_date': date_str}, order_by="metric_name ASC")

    # Helper methods for date/datetime conversion to be added to BaseModel or used here
    # (These were defined in BaseModel example previously, assuming they exist there)
    def _iso_to_date(self, iso_date_string: Optional[str]) -> Optional[datetime.date]:
        """Converts an ISO 8601 date string (YYYY-MM-DD) to a date object."""
        if iso_date_string:
            try:
                return datetime.datetime.strptime(iso_date_string, '%Y-%m-%d').date()
            except (ValueError, TypeError) as e:
                logger.warning(f"Could not parse date string '{iso_date_string}': {e}")
                return None
        return None

    def _date_to_iso(self, date_object: Optional[datetime.date]) -> Optional[str]:
        """Converts a date object to an ISO 8601 string (YYYY-MM-DD)."""
        if date_object and isinstance(date_object, datetime.date):
            return date_object.isoformat()
        return None

    def __repr__(self) -> str:
        """
        Provides a developer-friendly string representation of the ReportData instance.
        """
        return (
            f"<ReportData(id={self.id}, report_db_id={self.report_db_id}, "
            f"metric='{self.metric_name}'='{self.metric_value}', date='{self.data_date}')>"
        )
```
