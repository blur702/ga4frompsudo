# 15 - Utility: Formatters

This file provides the pseudocode for data formatting utility functions. These helpers will be used to present data (numbers, percentages, durations, dates, file sizes) in a more human-readable format in the views or reports.

**Target Application File:** `app/utils/formatters.py`
**Corresponding Test File (to be generated by LLM):** `tests/unit/utils/test_formatters.py`. Tests should cover each formatting function with various inputs, including valid values, edge cases (e.g., zero, large numbers, None), and different precision requirements.

## Pseudocode for Application Code (`app/utils/formatters.py`)

```python
"""
Data Formatting Utilities.

This module provides a collection of functions to format various data types
(numbers, percentages, durations, dates, file sizes) into human-readable strings
suitable for display in user interfaces or reports.
"""

import datetime
import logging
from typing import Union, Optional, Any # For type hinting

logger = logging.getLogger(__name__)

def format_number(
    num: Union[int, float, None],
    decimal_places: int = 0,
    default_on_error: str = "N/A"
) -> str:
    """
    Formats a number with thousands separators and a specified number of decimal places.

    Args:
        num (Union[int, float, None]): The number to format.
        decimal_places (int, optional): The number of decimal places to display.
                                        Defaults to 0.
        default_on_error (str, optional): The string to return if `num` is None or
                                          cannot be formatted. Defaults to "N/A".

    Returns:
        str: The formatted number as a string, or `default_on_error` if input is invalid.
    """
    if num is None:
        return default_on_error
    if not isinstance(num, (int, float)):
        logger.warning(f"Invalid type for format_number: {type(num)}. Expected int or float.")
        return default_on_error
    if not isinstance(decimal_places, int) or decimal_places < 0:
        logger.warning(f"Invalid decimal_places: {decimal_places}. Must be a non-negative integer. Using 0.")
        decimal_places = 0

    try:
        return f"{num:,.{decimal_places}f}"
    except (ValueError, TypeError) as e:
        logger.error(f"Error formatting number {num} with {decimal_places} decimal places: {e}")
        return default_on_error

def format_percentage(
    num: Union[float, int, None],
    decimal_places: int = 2,
    default_on_error: str = "N/A"
) -> str:
    """
    Formats a number (expected to be a proportion, e.g., 0.25 for 25%) as a percentage string.

    Args:
        num (Union[float, int, None]): The number to format (e.g., 0.75 for 75%).
        decimal_places (int, optional): The number of decimal places for the percentage.
                                        Defaults to 2.
        default_on_error (str, optional): String to return if `num` is None or formatting fails.
                                          Defaults to "N/A".

    Returns:
        str: The formatted percentage string (e.g., "75.00%"), or `default_on_error`.
    """
    if num is None:
        return default_on_error
    if not isinstance(num, (int, float)):
        logger.warning(f"Invalid type for format_percentage: {type(num)}. Expected int or float.")
        return default_on_error
    if not isinstance(decimal_places, int) or decimal_places < 0:
        logger.warning(f"Invalid decimal_places: {decimal_places}. Must be a non-negative integer. Using 2.")
        decimal_places = 2

    try:
        percentage_value = num * 100
        return f"{percentage_value:.{decimal_places}f}%"
    except (ValueError, TypeError) as e:
        logger.error(f"Error formatting percentage {num} with {decimal_places} decimal places: {e}")
        return default_on_error

def format_duration(
    seconds: Union[int, float, None],
    default_on_error: str = "N/A"
) -> str:
    """
    Formats a duration in seconds into a human-readable string (e.g., "Xh Ym Zs", "Ym Zs", "Zs").

    Args:
        seconds (Union[int, float, None]): The duration in seconds.
        default_on_error (str, optional): String to return if `seconds` is None or formatting fails.
                                          Defaults to "N/A".

    Returns:
        str: The formatted duration string, or `default_on_error`.
    """
    if seconds is None:
        return default_on_error
    if not isinstance(seconds, (int, float)):
        logger.warning(f"Invalid type for format_duration: {type(seconds)}. Expected int or float.")
        return default_on_error
    if seconds < 0:
        logger.warning(f"Negative duration provided: {seconds}s. Formatting absolute value.")
        seconds = abs(seconds)

    try:
        s = int(round(seconds)) # Round to nearest second

        if s == 0:
            return "0s"

        hours, remainder = divmod(s, 3600)
        minutes, secs = divmod(remainder, 60)

        parts = []
        if hours > 0:
            parts.append(f"{hours}h")
        if minutes > 0:
            parts.append(f"{minutes}m")
        if secs > 0 or not parts: # Always show seconds if it's the only unit or non-zero
            parts.append(f"{secs}s")

        return " ".join(parts)
    except (ValueError, TypeError) as e:
        logger.error(f"Error formatting duration for {seconds} seconds: {e}")
        return default_on_error


def format_date_pretty(
    date_obj: Union[datetime.date, datetime.datetime, str, None],
    output_format: str = "%B %d, %Y", # e.g., "May 13, 2025"
    default_on_error: str = "N/A"
) -> str:
    """
    Formats a date object (date, datetime) or a date string into a human-readable string.
    This is a more specific version of a general date formatter, focused on a common "pretty" format.
    (Note: `app.utils.date_utils.format_date_for_display` provides similar functionality;
     this can be a refinement or an alternative focused on a specific common format.)

    Args:
        date_obj (Union[datetime.date, datetime.datetime, str, None]):
            The date or datetime object to format, or a string representation.
            Supported string formats: 'YYYY-MM-DD' or full ISO 8601 datetime strings.
        output_format (str, optional): The desired output format string (strftime codes).
        default_on_error (str, optional): String to return if input is None or parsing/formatting fails.

    Returns:
        str: The formatted date string, or `default_on_error`.
    """
    if date_obj is None:
        return default_on_error

    date_to_format: Optional[Union[datetime.date, datetime.datetime]] = None

    if isinstance(date_obj, str):
        try:
            # Attempt to parse as a full datetime first
            if date_obj.endswith('Z'): # Handle UTC 'Z' notation explicitly
                date_to_format = datetime.datetime.fromisoformat(date_obj.replace('Z', '+00:00'))
            else:
                date_to_format = datetime.datetime.fromisoformat(date_obj)
        except ValueError:
            try:
                # If full datetime parse fails, try as date only 'YYYY-MM-DD'
                date_to_format = datetime.datetime.strptime(date_obj, '%Y-%m-%d').date()
            except ValueError:
                logger.warning(f"Could not parse date string for pretty formatting: '{date_obj}'")
                return default_on_error
    elif isinstance(date_obj, (datetime.datetime, datetime.date)):
        date_to_format = date_obj
    else:
        logger.warning(f"Invalid type for format_date_pretty: {type(date_obj)}. Expected date, datetime, or str.")
        return default_on_error

    if date_to_format is None: # Should be caught by earlier checks, but as a safeguard
        return default_on_error

    try:
        return date_to_format.strftime(output_format)
    except (AttributeError, ValueError) as e: # AttributeError if None, ValueError for bad format codes
        logger.error(f"Error pretty formatting date '{date_obj}' with format '{output_format}': {e}")
        return default_on_error


def format_file_size(
    size_bytes: Union[int, float, None],
    binary_system: bool = True, # True for KiB, MiB, GiB; False for KB, MB, GB
    decimal_places: int = 2,
    default_on_error: str = "N/A"
) -> str:
    """
    Formats a file size in bytes into a human-readable string (e.g., "1.23 MiB", "256 B").

    Args:
        size_bytes (Union[int, float, None]): The file size in bytes.
        binary_system (bool, optional): If True, uses binary prefixes (KiB, MiB, GiB - powers of 1024).
                                        If False, uses decimal prefixes (KB, MB, GB - powers of 1000).
                                        Defaults to True.
        decimal_places (int, optional): Number of decimal places for the formatted size.
                                        Defaults to 2.
        default_on_error (str, optional): String to return if `size_bytes` is None or invalid.
                                          Defaults to "N/A".

    Returns:
        str: The formatted file size string, or `default_on_error`.
    """
    if size_bytes is None:
        return default_on_error
    if not isinstance(size_bytes, (int, float)):
        logger.warning(f"Invalid type for format_file_size: {type(size_bytes)}. Expected int or float.")
        return default_on_error
    if size_bytes < 0:
        logger.warning(f"Negative file size provided: {size_bytes}. Using absolute value.")
        size_bytes = abs(size_bytes)
    if not isinstance(decimal_places, int) or decimal_places < 0:
        logger.warning(f"Invalid decimal_places: {decimal_places}. Must be non-negative. Using 2.")
        decimal_places = 2

    factor = 1024.0 if binary_system else 1000.0
    if binary_system:
        units = ['B', 'KiB', 'MiB', 'GiB', 'TiB', 'PiB', 'EiB', 'ZiB', 'YiB']
    else:
        units = ['B', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB']

    unit_index = 0
    val = float(size_bytes)

    while val >= factor and unit_index < len(units) - 1:
        val /= factor
        unit_index += 1

    try:
        return f"{val:,.{decimal_places}f} {units[unit_index]}"
    except (ValueError, TypeError) as e:
        logger.error(f"Error formatting file size {size_bytes}: {e}")
        return default_on_error
```
