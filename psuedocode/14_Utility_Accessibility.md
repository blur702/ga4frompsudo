# 14 - Utility: Accessibility Utilities

This file provides pseudocode for accessibility-related utilities. While true accessibility compliance often involves a combination of automated tools, manual testing, and adherence to design principles, this module can contain helper functions or classes that assist in checking for common issues or providing guidance. The primary goal mentioned in the project is WCAG AA compliance.

**Target Application File:** `app/utils/accessibility_utils.py`
**Corresponding Test File (to be generated by LLM):** `tests/unit/utils/test_accessibility_utils.py`. Tests should cover any concrete checking logic implemented (e.g., if the `validate_html` method had more specific checks, those would be tested). For now, tests might focus on ensuring the `AccessibilityChecker` class can be instantiated and its methods return the expected structure of guidelines.

## Pseudocode for Application Code (`app/utils/accessibility_utils.py`)

```python
"""
Accessibility related utilities.

This module provides tools and guidelines to assist with developing an accessible
application, aiming for WCAG AA compliance. It includes a basic checker class
that can be expanded with more specific validation logic or integration with
external accessibility testing libraries.
"""

import logging
from typing import Dict, List, Any # For type hinting

logger = logging.getLogger(__name__)

class AccessibilityChecker:
    """
    A utility class to provide guidelines and potentially perform basic checks
    for web accessibility, based on WCAG (Web Content Accessibility Guidelines) principles.

    This class is intended as a helper and a reminder of accessibility considerations.
    For comprehensive accessibility validation, dedicated automated tools (e.g., Axe,
    Lighthouse) and manual testing by accessibility experts are essential.
    """

    def __init__(self):
        """
        Initializes the AccessibilityChecker.
        Loads or defines a checklist of WCAG AA criteria to consider.
        """
        self.wcag_aa_principles_guidelines = self._get_wcag_aa_summary()
        self.template_development_guidelines = self._get_template_guidelines()
        logger.info("AccessibilityChecker initialized with WCAG AA summary and template guidelines.")

    def _get_wcag_aa_summary(self) -> Dict[str, List[str]]:
        """
        Provides a high-level summary of WCAG principles and some AA guidelines.
        This is not exhaustive but serves as a quick reference.

        Returns:
            Dict[str, List[str]]: A dictionary where keys are WCAG principles
                                  (Perceivable, Operable, Understandable, Robust)
                                  and values are lists of example guideline areas
                                  relevant to AA compliance.
        """
        return {
            "Perceivable": [
                "Provide text alternatives for non-text content (e.g., alt text for images - 1.1.1).",
                "Provide captions and other alternatives for multimedia (e.g., for pre-recorded audio/video - 1.2.2, 1.2.3, 1.2.5).",
                "Create content that can be presented in different ways without losing information or structure (e.g., semantic HTML - 1.3.1, 1.3.2).",
                "Make it easier for users to see and hear content including separating foreground from background (e.g., color contrast 4.5:1 for text - 1.4.3, resizable text - 1.4.4)."
            ],
            "Operable": [
                "Make all functionality available from a keyboard (2.1.1, 2.1.2 - no keyboard trap).",
                "Provide users enough time to read and use content (2.2.1 - timing adjustable, 2.2.2 - pause, stop, hide for moving content).",
                "Do not design content in a way that is known to cause seizures (2.3.1 - three flashes or below threshold).",
                "Provide ways to help users navigate, find content, and determine where they are (e.g., page titles, focus order, link purpose - 2.4.2, 2.4.3, 2.4.4, 2.4.7 - visible focus)."
            ],
            "Understandable": [
                "Make text content readable and understandable (3.1.1 - language of page, 3.1.2 - language of parts).",
                "Make web pages appear and operate in predictable ways (3.2.1 - on focus, 3.2.2 - on input - no unexpected context changes).",
                "Help users avoid and correct mistakes (3.3.1 - error identification, 3.3.2 - labels or instructions)."
            ],
            "Robust": [
                "Maximize compatibility with current and future user agents, including assistive technologies (4.1.1 - parsing, 4.1.2 - name, role, value for UI components)."
            ]
        }

    def _get_template_guidelines(self) -> Dict[str, str]:
        """
        Provides specific guidelines for developers when creating HTML templates and frontend code.

        Returns:
            Dict[str, str]: A dictionary where keys are guideline topics and
                            values are descriptive recommendations.
        """
        return {
            "Semantic HTML": "Use HTML5 semantic elements (e.g., <nav>, <main>, <article>, <aside>, <header>, <footer>) appropriately to define page structure.",
            "Image Alt Text": "All <img> tags must have descriptive `alt` attributes. For purely decorative images, use `alt=\"\"`.",
            "Form Labels": "All form input controls (<input>, <textarea>, <select>) must have associated <label> elements using `for` and `id` attributes, or be wrapped by the label.",
            "Keyboard Navigation": "Ensure all interactive elements (links, buttons, form fields, custom widgets) are focusable and operable using only the keyboard.",
            "Focus Indicators": "Ensure that keyboard focus is always clearly visible and distinguishable for all interactive elements.",
            "ARIA Attributes": "Use ARIA (Accessible Rich Internet Applications) attributes appropriately for custom widgets and complex UI elements to define roles, states, and properties (e.g., `role`, `aria-label`, `aria-labelledby`, `aria-describedby`, `aria-expanded`, `aria-hidden`).",
            "Skip Links": "Provide 'skip to main content' links for users who navigate with a keyboard to bypass repetitive navigation blocks.",
            "Color Contrast": "Ensure text and interactive elements have sufficient color contrast against their background (WCAG AA requires 4.5:1 for normal text, 3:1 for large text).",
            "Resizable Text": "Ensure text can be resized up to 200% without loss of content or functionality.",
            "Error Messages": "Error messages for form validation should be clear, specific, and programmatically associated with the form field in error.",
            "Page Titles": "Each web page must have a unique and descriptive <title> element.",
            "Language Declaration": "Specify the language of the page using the `lang` attribute on the <html> element (e.g., `<html lang=\"en\">`)."
        }

    def get_wcag_summary(self) -> Dict[str, List[str]]:
        """Public method to access the WCAG AA summary."""
        return self.wcag_aa_principles_guidelines

    def get_development_guidelines(self) -> Dict[str, str]:
        """Public method to access template development guidelines."""
        return self.template_development_guidelines

    def basic_html_validation(self, html_content: str) -> List[str]:
        """
        Performs very basic, non-exhaustive checks on HTML content for common accessibility issues.
        This is a placeholder for what could be more sophisticated checks or integration
        with an external HTML validation/linting tool focused on accessibility.

        Args:
            html_content (str): A string containing HTML content to validate.

        Returns:
            List[str]: A list of potential accessibility issue descriptions found.
                       An empty list indicates no issues were found by these basic checks.
        """
        if not isinstance(html_content, str):
            logger.error("basic_html_validation expects a string input for html_content.")
            return ["Invalid input: HTML content must be a string."]

        issues: List[str] = []

        # Example Check 1: Missing alt attributes on img tags (very basic check)
        # A more robust check would use an HTML parser.
        import re # Use regex for simple pattern matching in this basic example
        img_tags = re.findall(r'<img [^>]*>', html_content, re.IGNORECASE)
        for img_tag in img_tags:
            if not re.search(r'alt\s*=\s*(".*?"|\'.*?\')', img_tag, re.IGNORECASE):
                issues.append(f"Potential Issue: Image tag may be missing an alt attribute or has an empty one. Tag: {img_tag[:70]}...")

        # Example Check 2: Presence of positive tabindex values (generally discouraged)
        if re.search(r'tabindex\s*=\s*"\s*[1-9]\d*\s*"', html_content, re.IGNORECASE) or \
           re.search(r"tabindex\s*=\s*'\s*[1-9]\d*\s*'", html_content, re.IGNORECASE):
            issues.append("Potential Issue: Positive tabindex values found. These can disrupt the natural tab order and should generally be avoided.")

        # Example Check 3: Check for click handlers without equivalent keyboard handlers (very simplistic)
        # This is hard to do reliably without parsing JS and understanding context.
        # if "onclick=" in html_content.lower() and not ("onkeydown=" in html_content.lower() or "onkeypress=" in html_content.lower()):
        #     issues.append("Potential Issue: Found 'onclick' handlers; ensure equivalent keyboard accessible handlers are present for interactive elements.")
        # This check is too naive and prone to false positives, so commented out.
        # A better approach would be to check specific elements for keyboard event handlers if they have click handlers.

        if not issues:
            logger.info("Basic HTML validation found no immediate accessibility red flags (note: checks are very limited).")
        else:
            logger.warning(f"Basic HTML validation found {len(issues)} potential issues.")
        return issues

    def generate_accessibility_report(self, html_content: Optional[str] = None) -> Dict[str, Any]:
        """
        Generates a basic accessibility report, including guidelines and results from
        any simple HTML validation performed.

        Args:
            html_content (Optional[str]): HTML content string to perform basic checks on.
                                          If None, only guidelines are returned.

        Returns:
            Dict[str, Any]: A dictionary containing the accessibility report.
                            Includes keys like 'status', 'issues_found', 'wcag_summary',
                            and 'development_guidelines'.
        """
        report: Dict[str, Any] = {
            "status": "info", # Default status
            "issues_found": [],
            "wcag_summary": self.get_wcag_summary(),
            "development_guidelines": self.get_development_guidelines()
        }

        if html_content:
            issues = self.basic_html_validation(html_content)
            report["issues_found"] = issues
            report["status"] = "pass_basic_checks" if not issues else "fail_basic_checks"
        else:
            report["status"] = "guidelines_only"
            report["issues_found"].append("No HTML content provided for basic validation.")

        logger.info(f"Generated accessibility report with status: {report['status']}")
        return report
```
